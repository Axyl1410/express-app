#!/bin/sh
# Don't exit on error immediately - we need to clean up
set +e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" 2>/dev/null
STASHED=$?

# Run formatter on the staged files
pnpm dlx ultracite fix
FORMAT_EXIT_CODE=$?

# Re-stage the formatted files first
if [ -n "$STAGED_FILES" ]; then
  echo "$STAGED_FILES" | while IFS= read -r file; do
    if [ -f "$file" ]; then
      git add "$file" 2>/dev/null || true
    fi
  done
fi

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Try to restore unstaged changes, but if there are conflicts, 
  # accept the formatted version (ours) and drop the stash
  if ! git stash pop --quiet 2>/dev/null; then
    # If stash pop fails (conflicts), check if it's a real conflict
    if [ -n "$(git diff --check 2>/dev/null)" ] || [ -n "$(git ls-files -u)" ]; then
      # There are conflicts - resolve by keeping the formatted version
      git checkout --ours . 2>/dev/null || true
      git add . 2>/dev/null || true
      git stash drop --quiet 2>/dev/null || true
      echo "⚠️  Resolved formatting conflicts by keeping formatted version"
    else
      # No real conflicts, just try again
      git stash pop --quiet 2>/dev/null || git stash drop --quiet 2>/dev/null || true
    fi
  fi
  
  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - restore the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        # Try to restore unstaged changes, but don't fail if it doesn't work
        git restore "$file" 2>/dev/null || true
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "✨ Files formatted by Ultracite"
fi

# Exit with formatter's exit code
exit $FORMAT_EXIT_CODE
